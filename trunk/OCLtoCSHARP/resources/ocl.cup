import java_cup.runtime.*;
action code {: private int count = 0; private String getId() { count++; return count + "";} :};

/* Terminais (tokens vindos do lexer) */
terminal            PRE, POS, INV, SELECT, EXISTS, FORALL, IF, THEN, ELSE, IMPLIES, INCLUDING, EXCLUDING, OCLISNEW, ATPRE, RESULT, SIZE, CONTEXT, LPAREN, RPAREN;
terminal			LCOLCH, RCOLCH, LCHAVE, RCHAVE, DOISPONTOS, QUATROPONTOS, VIRGULA, IGUAL, DIFF, MENORQ, MAIORQ, MENORIGUAL, MAIORIGUAL, SETA, PONTOPONTO;
terminal			PONTO, SHARP, PONTOVIRGULA, BARRA, MAIS, MENOS, VEZES, DIVIDIR;
terminal Atributos	ID;
terminal Atributos			STRING, BOOLEAN, NUMBER, SET, BAG, SEQUENCE, COLLECTION;
terminal Atributos	INTEGER;
terminal 			VOID, AND, OR, XOR, NOT, ENDIF, INTTYPE, REALTYPE, PACKAGE, ENDPACKAGE;
terminal Atributos		REAL;
terminal Atributos	TRUE, FALSE;


/* Não terminais */
non terminal	Atributos OCLFile, OCLConstraints, Constraint, ContextDeclaration, ContextBody, Stereotype, OCLExpression, OperationContext, ClassifierContext;
non terminal	Atributos			OperationName, FormalParameters,  ReturnType, FormalParameter, TypeSpecifier, CollectionType, SimpleTypeSpecifier, PathName, OCLLiteral;
non terminal	Atributos		BoolValue, Number;
//Expressions
non terminal	Atributos		PostFixExpression, LogicalExpression, NumberExpression, RelationalExpression, PropertyCall, PropertyCallExpression, AdditiveExpression, MultiplicativeExpression, UnaryExpression, PrimaryExpression, InvExpression, PreExpression, EqualityExpression;
//Operators
non terminal	Atributos 		MultiplyOperator, PostfixOperator, RelationalOperator, UnaryOperator, MultOperator, AddOperator, LogicalOperator;
//Conditional Expressions
non terminal	Atributos			ConditionalExpression, IfExpression, ImpliesExpression;
//Collections
non terminal	Atributos			CollectionItems, CollectionExpression, LiteralCollection, CollectionOperations, SelectOperation, ExistsOperation, IncludingOperation, ExcludingOperation, ForAllOperation, SizeOperation, CollectionParameters;

precedence left IMPLIES;
precedence left XOR;
precedence left OR;
precedence left AND;
precedence left DIFF, IGUAL;
precedence left MENORIGUAL, MAIORIGUAL, MENORQ, MAIORQ;
precedence left IF, THEN, ELSE, ENDIF;
precedence left MAIS, MENOS;
precedence left VEZES, DIVIDIR;
precedence left PONTO, SETA;


/* Regras */
// Regra Inicial
start with OCLFile;
// Regras para constraints
OCLFile ::= PACKAGE ID OCLConstraints ENDPACKAGE
				| OCLConstraints;
OCLConstraints ::= Constraint OCLConstraints | Constraint;
Constraint ::= ContextDeclaration ContextBody;
ContextDeclaration ::= CONTEXT OperationContext 
				| CONTEXT ClassifierContext;
ContextBody ::= InvExpression
				| PreExpression;
InvExpression ::= INV DOISPONTOS OCLExpression
				| INV ID DOISPONTOS OCLExpression;
PreExpression ::= PRE DOISPONTOS OCLExpression
				| PRE ID DOISPONTOS OCLExpression
				| POS DOISPONTOS OCLExpression
				| POS ID DOISPONTOS OCLExpression
				| PRE DOISPONTOS OCLExpression POS DOISPONTOS OCLExpression
				| PRE ID DOISPONTOS OCLExpression POS ID DOISPONTOS OCLExpression;

OperationContext ::= ID QUATROPONTOS PropertyCall  
				| ID QUATROPONTOS PropertyCall DOISPONTOS TypeSpecifier ;
ClassifierContext ::= ID:i DOISPONTOS ID {:
					if (!XmiParser.isValidClass(i.Value.toString())){
						System.err.println("\n\nERRO DE COMPILACAO, NAO EXISTE CLASSE " + i.Value.toString() + " DEFINIDA NO XMI1");
						System.exit(0);
					}
				:} 
				| ID:i {: 
					if (!XmiParser.isValidClass(i.Value.toString())){
						System.err.println("\n\nERRO DE COMPILACAO, NAO EXISTE CLASSE " + i.Value.toString() + " DEFINIDA NO XMIz");
						System.exit(0);}
					:};

// Expressões 
OCLExpression ::= LogicalExpression;
LogicalExpression ::= RelationalExpression
				| RelationalExpression LogicalOperator LogicalExpression;
RelationalExpression  ::= AdditiveExpression
				| AdditiveExpression RelationalOperator RelationalExpression;
AdditiveExpression ::= MultiplicativeExpression:e {: RESULT = e; :}
				| MultiplicativeExpression:e1 AddOperator:o AdditiveExpression:e2
				{:
				if(e1.Type == Integer.class && e2.Type == Integer.class){
						if(o.Value.equals("+")){
							RESULT = new Atributos(Integer.class, new Integer( (int) ( ((Integer)e1.Value).intValue() + ((Integer)e2.Value).intValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println(RESULT.Value.toString());
						} else if (o.Value.equals("-")){
							RESULT = new Atributos(Integer.class, new Integer( (int) ( ((Integer)e1.Value).intValue() - ((Integer)e2.Value).intValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println(RESULT.Value.toString());
						}
			   	} else if( (e1.Type == Double.class && e2.Type == Double.class) ||
				          (e1.Type == Integer.class && e2.Type == Double.class) ||
				          (e1.Type == Double.class && e2.Type == Integer.class) ) {
			   			if(o.Value.equals("+")){
							RESULT = new Atributos(Double.class, new Double( (double) ( ((Double)e1.Value).doubleValue() + ((Double)e2.Value).doubleValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println(RESULT.Value.toString());
						} else if (o.Value.equals("-")){
							RESULT = new Atributos(Double.class, new Double( (double) ( ((Double)e1.Value).doubleValue() - ((Double)e2.Value).doubleValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println(RESULT.Value.toString());
						}
			   	} else {
			   			System.err.println("\n\nERRO DE COMPILACAO AdditiveExpression");
			   			System.exit(0);
	   			}
				:};
MultiplicativeExpression ::= UnaryExpression:e {: RESULT = e; :}
				| UnaryExpression:e1 MultOperator:o MultiplicativeExpression:e2
				{:
				if(e1.Type == Integer.class && e2.Type == Integer.class){
						if(o.Value.equals("*")){
							RESULT = new Atributos(Integer.class, new Integer( (int) ( ((Integer)e1.Value).intValue() * ((Integer)e2.Value).intValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println("ALOK1");
						} else if (o.Value.equals("/")){
							RESULT = new Atributos(Integer.class, new Integer( (int) ( ((Integer)e1.Value).intValue() / ((Integer)e2.Value).intValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println("ALOK2");
						}
			   	} else if( (e1.Type == Double.class && e2.Type == Double.class) ||
				          (e1.Type == Integer.class && e2.Type == Double.class) ||
				          (e1.Type == Double.class && e2.Type == Integer.class) ) {
			   			if(o.Value.equals("*")){
							RESULT = new Atributos(Double.class, new Double( (double) ( ((Double)e1.Value).doubleValue() * ((Double)e2.Value).doubleValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println("ALOK1");
						} else if (o.Value.equals("/")){
							RESULT = new Atributos(Double.class, new Double( (double) ( ((Double)e1.Value).doubleValue() / ((Double)e2.Value).doubleValue() )), e1.Code + " " + o.Code + " " + e2.Code);
							System.out.println("ALOK2");
						}
			   	} else {
			   			System.err.println("\n\nERRO DE COMPILACAO MultiplicativeExpression");
			   			System.exit(0);
	   			}
				:};
UnaryExpression ::= PrimaryExpression:p {: RESULT = p; :}
				| UnaryOperator UnaryExpression
				| PrimaryExpression UnaryOperator UnaryExpression;
PrimaryExpression ::= LiteralCollection:l {: RESULT = l; :}
				| IfExpression
				| LPAREN OCLExpression RPAREN
				| CollectionExpression
				;

LiteralCollection ::= Number:n {: RESULT = n; :}
				| BoolValue
				| STRING
				| PropertyCall
				| PropertyCall ATPRE;
IfExpression ::= IF LogicalExpression THEN  LogicalExpression  ELSE  LogicalExpression ENDIF;	

//Expressões em coleções				
CollectionExpression ::= CollectionOperations;
CollectionOperations ::= SelectOperation
				|ExistsOperation
				|IncludingOperation
				|ExcludingOperation
				|ForAllOperation
				|SizeOperation;
SelectOperation ::= SELECT LPAREN OCLExpression RPAREN
				| SELECT LPAREN CollectionParameters DOISPONTOS TypeSpecifier  BARRA OCLExpression RPAREN
				| SELECT LPAREN CollectionParameters BARRA OCLExpression RPAREN;
ExistsOperation ::= EXISTS LPAREN CollectionParameters DOISPONTOS TypeSpecifier BARRA OCLExpression RPAREN
				| EXISTS LPAREN CollectionParameters BARRA OCLExpression RPAREN
				| EXISTS LPAREN OCLExpression RPAREN;
IncludingOperation ::= INCLUDING LPAREN ID RPAREN;
ExcludingOperation ::= EXCLUDING LPAREN ID RPAREN;
ForAllOperation ::= FORALL LPAREN CollectionParameters DOISPONTOS TypeSpecifier BARRA OCLExpression RPAREN
				| FORALL LPAREN CollectionParameters BARRA OCLExpression RPAREN
				| FORALL LPAREN OCLExpression RPAREN;
SizeOperation ::= SIZE LPAREN RPAREN;
CollectionParameters ::= PropertyCall
				| PropertyCall VIRGULA CollectionParameters;


//Tipos
TypeSpecifier ::= PathName | INTTYPE | REALTYPE | VOID | STRING |  BOOLEAN ;
//Literais
PropertyCall ::= RESULT
				| PathName
				| PathName LPAREN RPAREN
				| PathName LPAREN FormalParameters RPAREN
				| PathName PONTO PropertyCall;
FormalParameters ::= FormalParameters VIRGULA FormalParameter
				|FormalParameter;				
FormalParameter ::= ID DOISPONTOS TypeSpecifier
				|PropertyCall;
PathName ::= ID | ID PONTO PathName ;
Number ::= INTEGER:i {:RESULT = new Atributos(i.Type,Integer.parseInt(i.Value.toString()),i.Value.toString());:}
			| REAL:r {: RESULT = new Atributos(r.Type,Double.parseDouble(r.Value.toString()),r.Value.toString());:};
BoolValue ::= TRUE | FALSE;
//Operators
LogicalOperator ::= AND | OR | XOR | IMPLIES;
CollectionKind ::= SET | BAG | SEQUENCE | COLLECTION;
RelationalOperator ::= MAIORQ | MAIORIGUAL | MENORQ | MENORIGUAL | IGUAL | DIFF;
AddOperator ::= MAIS {: RESULT = new Atributos(String.class,"+","+");:} | MENOS {: RESULT = new Atributos(String.class,"-","-");:};
MultiplyOperator ::= VEZES {: RESULT = new Atributos(String.class,"*","*"); :} | DIVIDIR {: RESULT = new Atributos(String.class,"/","/"); :};
UnaryOperator ::= NOT | MENOS | SETA;